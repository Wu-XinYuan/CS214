# 第八周作业

邬心远

519021910604

## 0413

### 第一题

#### 题目：

给定平面上一组点，已知每个点的坐标，求最远点对之间的距离，即点集的直径。（不得穷举，文献查阅，然后用自己的语言进行算法思想的描述，包括时间复杂性分析）  

#### 思路：

先利用凸包算法得到所有点集的凸包，可以用旋转扫描算法（复杂度$O(n\log n)$)。

之后利用旋转卡壳算法计算凸包直径即为最远点对的距离。

旋转卡壳法中用两条与多边形的边相交的平行线卡住多边形，此时可以记录与多边形相交的两个顶点的距离，之后不断旋转这两条平行线至能恰好卡住多边形，记录距离，寻找最大值。

#### 伪代码：

```
算法：寻找最远点对
输入：点集p1、p2、...、pn
输出：最远距离d
begin
	# graham扫描算法
	p1:=x最大的点
	按离p1的距离给点排序，最后为p1,p2,...,pn;
	q1:=p1, q2:=p2, q3:=p3;
	m:=3;
    for k:=4 to n do
        while the angle between -qm-1-qm- and -qm-pk- is >=180 degrees do
            m:=m-1;
        m:=m+1;
        qm:=pk;
        
    # 旋转卡壳法
    r1:=q1,q2,...,qn中y坐标最大的点的下标
    r2:=q1,q2,...,qn中y坐标最小的点的下标
    d:=distace(q[r1],q[r2])
    for(i:=0; i<num; ++i)
    	r1:=r1%num+1
    	while(distance(q[r2+1],q[r1])>distance(q[r2],q[r1]))
    		r2++;
    	d:=max(d,distance(q[r2],q[r1]))
end

```

#### 复杂性分析：

闭包算法复杂度$O(n\log n)$，旋转卡壳法复杂度$O(n)$，总复杂度为复杂度$O(n\log n)$)

### 第二题

#### 题目

给定测度空间中位于同一平面的 $n$ 个点，已知任意两点之间的距离 $d_{ij}$，存储在矩阵 $D$ 中，求这组点的直径。
该问题的直观解法就是把 $D$ 扫描一遍，选择其中最大的元素即可。由于是在一个测度空间中，因此 $d_{ij}$满足距离的基本要求，即非负性、对称性和三角不等式，我们就可以给出一种时间亚线性的近似算法。算法很简单，由原来确定性算法的检查整个矩阵改为只随机检查 $D$ 的某一行，这样时间复杂性就由原来的 $O(n^2)$ 减少为 $O(n)$ ，相对于输入规模 $n^2$ 而言，这是一个时间亚线性的算法。
证明时间代价减小的同时，解不会小于最优值的一半 

#### 证明

在矩阵中随机取一行相当于在平面中任取一个点考察其他点与它的距离，证明其他点与这个点中的最大值一定能大于最优解的一半。

证明

1. 最大的距离就在找到的这一行中，即距离最大的两个点中有一个就是选中的这个点，那么直接是最优解。
2. 最大的距离不在这一行中，即距离最大的两个点中不包含选中的这个点，设找出的这个点为x，其余所有点到x的最大距离为$d_0$，那么假设这两个点到选中点的距离分别为d1、d2，那么这两个点间的距离d一定小于等于d1+d2，$d \le d_1 + d_2 \le d_0 + d_0 =2d_0$，也就是$d_0\ge \frac{d}{2}$，一定大于等于最优解的一半

<img src="C:\Users\wxy\Documents\Tencent Files\1145413987\FileRecv\MobileFile\1E1C937F89AF0273E683AEB0BBA7EFF3.png" alt="1E1C937F89AF0273E683AEB0BBA7EFF3" style="zoom:50%;" />

#### 第三题

#### 题目

在平面上给定一个有 $n$ 个点的集合 $S$，求 $S$ 的极大点。极大点的定义：设 $p1=(x1,y1)$ 和$p2 =(x2,y2)$ 是平面上的两个点，如果 $x1\le x2$ 并且 $y1\le y2$，则称 p2 支配 p1，记为$p_1<p_2$。点集 S 中的点 p 为极大点，意味着在 S 中找不到一个点 $q$，$q\ne p$ 并且$p < q$，即 $p$ 不被 S 中其它点支配。  

#### 思路

将所有点根据 $y$ 坐标排序，先选出 $y$ 坐标最大的点，一定是极大点。同时记录已有的极大点中 $x$ 的最大值，之后按照y的顺序遍历点，看是否满足之前极大点中最大的x比它的x小，如果满足，将其加入极大点序列，并更新x最大值

#### 伪代码

```
输入：点集p1,p2,...pn
输出：极大点点集Q
begin
	按y坐标降序给P排序
	把p[1]放入Q
	maxx:=p[1].x
	for(i:=2; i<=num; ++i)
		if(p[i].x>maxx)
			maxx=p[i].x
			p[i]放入Q
end
```



## 0415

### 第一题

#### 题目

对凸多边形

1）有多少种三角划分的方法？

2）如何使对角线长度之和最小？如果觉得递推式不好求，写出递归式就可以了  

#### 答

1)对于一个凸多边形，选定一条边，最后的划分中必有一个以它为底，剩下的 $n-2$ 个点中的某点一起构成的三角形，剩下的区域被这个三角形分成一个 $k$ 边形和一个 $n-k+1$ 边形。

<img src="C:\Users\wxy\Documents\Tencent Files\1145413987\FileRecv\MobileFile\EBB642CC199F4F60EFD1AB8A3BE6E01A.png" alt="EBB642CC199F4F60EFD1AB8A3BE6E01A" style="zoom:50%;" />

可以得到 $ A_2 = 1$，$A_3=1$，$A_n = \sum_{k=2}^{n-1}A_kA_{n-k+1}$ 

2)可以采用第一题的思想，递归

```
输入：多边形顶点点集p1,p2,...pn
输出：最小长度d
findmax(P)
	d := 0
	#将P1,P2作为选定边
	for (i:=3; i<=n; ++i)
		tmp := distace(p[1], p[i])+distance(p[2],p[i])
		d := max(d, tmp+findmin(p[2], p[3],...p[i])*findmin(p[1],p[i+1],...,p[n]))
```

因为遍历了每种可能，复杂度为$A_n$

### 第二问

#### 问题

给定平面上 n 条线段，设计算法用 O(nlogn)时间确定其中是否有两条线段相交。  

#### 思路

扫描线算法，复杂度$O(n\log n)$

#### 伪代码

```
输入：线段L1,L2,...Ln
输出：有无交点
begin
	对所有点p1,p2,...p2n进行升序排序并且放入最小堆E
	while E is not empty
    	p:=E堆顶
    	E顶出堆
        if p是l左端点：
           l加入S
           if 与上下线段相交：
               return True
        else
           删除s
           if 与上下线段相交
           	  return True
    return False
```



### 第三问

#### 问题：

用扫描线算法求解最近邻点对问题  

#### 思路：

维护当前最短距离，扫描到一个点时：

- 计算与队列里所有点的距离并更新最小值
- 把所有前面与扫描线距离大于当前最小距离的点剔除

#### 伪代码：

```
输入：p1,p2,...pn
输出：最短距离d
begin
	d:=MAX
	P放入最小堆E
	while E is not empty
    	p:=E堆顶
    	E顶出堆
    	for q in S: 
    		tmp := distance(p,q)
    		if tmp < d:
    			d := tmp
    			while p.x-s[0].x > d:
    				S.remove(s[0])
    	S.append(p)
```

### 第四问

#### 问题：

有 n 种液体 S1,S2,…,Sn，都含有 A,B 两种成分，含量分别为{a1,b1},{a2,b2},…,{an,bn}，ai+bi<100%。现欲利用这 n 种液体配制目标液体 T，使之 A 和 B 的含量分别为 x 和 y。设计算法判别能否成功配制，并给出算法时间复杂性。  

#### 思路

将{a1,b1},{a2,b2},…,{an,bn}绘制在二维坐标系下，看{ai，bi}是否落在点集的凸包内

#### 伪代码

```
 begin
	 p1,p2,...pn = (a1,b1),(a2,b2),...,(an,bn)
    扫描算法：得到p1,p2,...pn凸包q1,q2,...qn
    取闭包外一点s
    x := (an,bn)
    cnt := 0
    for n := 1 to n
        if (x,s),(pi,pi+1)有交点
            cnt++
	if cnt%2 == 1 
		return True
	else
		return False
end
```

