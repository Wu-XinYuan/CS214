# 第九周作业

邬心远

519021910604

## 0420

### 第一题

#### 题目：

给定正整数 $a_1, a_2, ..., a_n$，代表 n 条线段（由点$(i,a_i)$和$(i,0)$构成，$i=1,2,…,n$），从中找出两
条线段，使之与 $x$ 轴构成的容器能够包含尽可能多的水  

#### 思路：

可以采用扫描线算法，从上到下进行扫描，考虑把扫描到的线作为最终容器的较短边，那么容器剩下的较高边一定是已经扫描过的（因为从高到低扫描），而且若要容器体积最大，那么较长边一定与它尽可能的远，只可能是之前的边中最左边或最右边的线，所以只需要在扫描过程中保存已扫描过的最左边与最右边。

#### 伪代码：

```
输入：线段长度a1,a2,...an
输出：最大容器大小s
begin:
	sort all the lines (xi,ai) by there height and put them into a array E
	 #l,r分别保存已经扫描过的最左和最右位置，s表示已算出来的最大面积
	s := 0
	l:(x,a)=E.popout(head)
	l,r := x
	while !E.empty():
		pop out its head l:(x,a)
		s := max(s, (x-l)*a, (r-x)*a)
		# 维护信息
		l := min(l, x)
		r := max(r, x)
end
```

#### 复杂度分析：

排序$O(nlogn)$, 后面维护$O(n)$, 总复杂性$O(nlogn)$

### 第二题

#### 题目：

海报墙由 $n$ 块宽度相同高度不同的木板组成，那么在此海报墙上能够张贴的最大海报面积是多少？设木板宽度为 1，高度为 $h_1,h_2,…,h_n$，海报必须整体都粘贴在墙上，并且不能斜贴。  

#### 思路：

还是可以利用类似第一题的扫描算法，需要维护的信息可以是某一个木板它右侧连续比他高的木板数量，以及左侧连续比它高的木板数量，在遇到一个新木板的时候进行更新。

在遇到新木板时，根据算法设计，能根据已有的维护信息可以知道左侧的比它高的连续长度为$l_1$，右侧连续比它高的木板长度为$l_2$，那么以它为最低模板的海报张贴面积就为$h*(l_1+1+l_2)$。

同时，可以看出只有还没有被扫描过的模板的左右最长连续长度时有价值的，而左右连续块内的木块一定是已经被扫描过的，不用再维护信息。遇到一个新木板时，只需要更新因为这块新木板而改变大小的连续块的边界，包括其原有左连续块的左邻居，原有右连续块的右邻居，更新的值就是上面用于计算的以它为最低高度的连续模板长度

下面为一个更新的例子，收尾两个只是为了操作方便，避免越界，无实际作用：

<img src="C:\Users\wxy\AppData\Roaming\Typora\typora-user-images\image-20210426235604490.png" alt="image-20210426235604490" style="zoom: 50%;" />

#### 伪代码：

```
输入：木板高度h1,h2,...hn
输出：最大海报大小s
begin:
	根据高度将id为1-n的木板排序，并把排序后的id顺序存在数组E中
	# 初始化保存左右连续木板长度的数组：
	for i:=0
		q[i].l, q[i].r := 0
	#s表示已算出来的最大面积, 初始化：
	s := 0
	while !E.empty():
		pop out E's head i #当前扫描第i块木板，高度h[i]
		width := q[i].l+q[r].r+1 #以当前扫描木板为最低高度的连续长度
		# 维护信息
		s := max(s, width*h[i])
		q[i-1-q[i].l].r := width
		q[i+1+q[i].r].l := width
end
```

#### 复杂度：

$O(nlogn)$

### 第三题

#### 题目：

平面有两组点，如何证明是否存在直线可以将这两组点分开  

#### 思路：

作出两组的凸包，判断凸包是否存在交集，如果两凸包相交，则不存在，不相交则存在

#### 伪代码：

```
输入：点集1{s11,s12,...,s1n1},点集2{s21,s22,...,s2n2}
输出：是否存在分割线
begin:
	凸包算法，得到点集1凸包Q1{p[1][1],p[1][2],...,p[1][m]},点集2凸包Q2{p[2][1],p[2][2],...,p[2][n]}
	将两个闭包中的点全部按x坐标排序并放入集合E中
	while !E.empty():
		p = E.popOutHead()
		if p是某条l1的起点:
			put l1 into set S
			if l1 与S中直线有交点：
				return false
			if 加上l1后y轴方向q1,q2中的线交替出现(比如一个凸包完全包含另一个):
				return false
		if p是某条l2的终点：
			remove l2 from set S
end
```

#### 复杂性

凸包算法$O(nlogn)$，扫描线也一样，总时间复杂性$O(n\log n)$

## 0422

### 第一题

#### 题目：

已知 n 个矩形，这些矩形的边都平行于坐标轴，

1）求出这些矩形的交集；

2）求出这些矩形能够覆盖的面积  

#### 思路：

1）分治法：两矩形交集一定是一个矩形，合并两个矩形复杂度常数时间

2）扫描线：状态：所有未结束的横边，有序队列；

事件：遇见竖边

#### 伪代码：

1）

```
输入：矩形集S #矩形用(x1,y1)表示左下角，(x2,y2)表示右上角
输出：交集
函数：
cap(set S):
	if S.size > 2:
		devide S into S1 and S2
		S={cap(S1),cap(s2)}
		return cap(S)
	if S.size = 1:
		return S[1]
	# 只处理两个合并：
	if (S[1]=NULL || S[2]=NULL):
		return NULL
	square r #用于返回
	r.x1 := max(S[1].x1, S[2],x1)
	r.x2 := max(S[1].x2, S[2],x2)
	r.y1 := max(S[1].y1, S[2],y1)
	r.y2 := max(S[1].y2, S[2],y2)
	if r.x1>r.x2 || r.y1>r.y2:
		return NULL
	else:
		return r
```

2)

```
输入：矩形集
输出：覆盖面积s
begin
	将所有矩形竖边按照横坐标排序，结果存在集合E中
	while !E.empty():
		l=E.popOutHead()
		if l 是某个矩形的左边：
			add l.y1, l.y2 into an ordered array A #A从大到小排列
		if l 是某个矩形s的右边
			height := 0 #将去掉的这块矩形贡献的高度
			if (l.y2 = max[A]) and l.y1=min(A)):
				height := l.y2 - l.y1
			else if(l.y2 = max[A]):
				height := l.y2 - max[A-l.y2] #距离下一高的
			else if (l.y1 = min[A]):
				height := min[A-l.y1] - l.y1
			s+=height*s.width
			remove l.y1, l.y2 from A
end
```

